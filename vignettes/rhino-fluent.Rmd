---
title: "Tutorial: Build a Rhino application using shiny.fluent"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Tutorial: Build a Rhino application using shiny.fluent}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: sentence
---

## 1. Hello World with `rhino` and `shiny.fluent`

### Getting started with our development environment

Let us first install and create our `rhino` project structure.

To install `rhino`, please run the following on a R console in your working directory

```         
install.packages("rhino")
```

Now that `rhino` is installed, let us use it to initiate a project which will give us a structure

```         
rhino::init()
```

You will notice that the working directory now has a proper folder structure along with some other files.
Among those, you will also notice that `renv` is being used to manage the packages/dependencies for the project.
So, let us now install `shiny.fluent` into the project.

```         
renv::install("shiny.fleunt")
```

Using renv for installation benefits us.
In particular, this means that the local cache of package installations is used when possible.
This helps to avoid re-downloading packages that have already been downloaded before, and re-compiling packages from source when a binary copy of that package is already available.

Now, head over to the `dependencies.R` file and add `library(shiny.fluent)` to it.
Upon saving the modified file, please take a snapshot of the dependencies so that the `renv.lock` file is updated.

```         
renv::snaphot()
```

Maintain this process whenever we need to install a new package in the project henceforth.

### Our first development on the app

-   Open the `app/main.R` file.

-   You will notice that currently it does not have any usage of `shiny.fluent` package to generate the text - "Hello".
    So let us introduce `shiny.fluent` and use it in our code to do the same action!

```         
box::use(
  shiny[moduleServer, NS, renderText, tags, textOutput],
  shiny.fluent[fluentPage, Text]
)

#' @export
ui <- function(id) {
  ns <- NS(id)
  fluentPage(
    Text("Hello!", variant = "mega")
  )
}

#' @export
server <- function(id) {
  moduleServer(id, function(input, output, session) {
  }
  )
}
```

The above code uses [`fluentPage`](https://appsilon.github.io/shiny.fluent/reference/fluentPage.html) and [`Text`](https://appsilon.github.io/shiny.fluent/reference/Text.html) from `shiny.fluent` package to render the UI and text.
You will also notice the [`NS(id)`](https://shiny.rstudio.com/reference/shiny/latest/ns) used in the code to return a namespace function, which has been saved as `ns` and will be invoked later in the shiny module.

Now when you run the app, you should be seeing this -

```{r, echo=FALSE}
knitr::include_graphics("images/rhino_fluent_1.png")
```

Note: If you check the built-in testcases once changes are introduced, running `rhino::test_r()` will give you errors.
To avoid failed github actions for now (in case you are pushing your code to Github), you may empty the test cases present in `tests\testthat\test-main.R`.

## 2. Show Data in a Table via a `rhino` module

So, in this section, we will introduce a table to our application that displays random imaginary sales deals.
The dataset comes from the `shiny.fluent` package itself - [fluentSalesDeals](https://appsilon.github.io/shiny.fluent/reference/fluentSalesDeals.html).

### Creating the module

-   In the `app\view\` folder, let us create a new file and name it `datatable.R`

-   This `app\view\datatable.R` file will be used to display the data table on the UI and we will call this module in the `app/main.R` file once done.
    Here is the code

    ```         
    box::use(
      shiny[moduleServer, NS],
      shiny.fluent[fluentPage, Text, DetailsList]
    )

    #' @export
    ui <- function(id) {
      ns <- NS(id)
        fluentPage(
            Text("A randomly generated dataset of imaginary sales deals"),
            DetailsList(items = shiny.fluent::fluentSalesDeals)
        )
    }

    #' @export
    server <- function(id) {
      moduleServer(id, function(input, output, session) {
      })
    }
    ```

So, here we are using [`DetailsList`](https://appsilon.github.io/shiny.fluent/reference/DetailsList.html) function to render the table.

### Calling the module

-   Go to `app/main.R` file and edit it with the following code

```         
box::use(
  shiny[moduleServer, NS],
  shiny.fluent[fluentPage, Text]
)

box::use(
  app/view/datatable,
)

#' @export
ui <- function(id) {
  ns <- NS(id)
  fluentPage(
    Text("Hello!", variant = "mega"),
    datatable$ui(ns("datatable"))
  )
}

#' @export
server <- function(id) {
  moduleServer(id, function(input, output, session) {
    datatable$server("datatable")
  }
  )
}
```

Notice here that we have called the `datatable` module by importing it to our main application file first.
It is now, that the main module will be able to use exported functions from `app/view/datatable.R`.

This code in the `app/main.R` file uses the concept of Shiny modules.
In the **`ui`** function, **`ns`** is used to create a unique namespace for the **`datatable`** element using the **`ns("datatable")`** syntax.
This is important because when the UI contains multiple instances of the same element (e.g. multiple tables), each instance must have a unique namespace to prevent naming conflicts in the server function.

In the **`server`** function, the **`ns`** function is not used directly, but its generated namespace is used as an argument for the **`datatable$server()`** function call.
This allows the server to reference the specific instance of the **`datatable`** element that is associated with the current session.

Now run the app.
You should be seeing something like this -

```{r, echo=FALSE}
knitr::include_graphics("images/rhino_fluent_2.png")
```

### Some improvements

#### Show informative columns with meaningful names

-   We will no more display all the columns that come with the dataset.
    Instead, we will display the `"rep_name", "date", "deal_amount", "city", "is_closed"` columns.

-   But for that we need to make the names more readable.
    So, we will assign proper names for every fields using the `tibble` package -

    ```         
    columns <- tibble(
        fieldName = c("rep_name", "date", "deal_amount", "city", "is_closed"),
        name = c("Sales Rep", "Date", "Deal Amount", "City", "Is Closed?"))
    ```

-   Also, we need to mention in the `DetailsList()` function inside UI to only display the names we just assigned in the `columns` object.
    Here is how the `ui` function now gets modified -

    ``` r
    #' @export
    ui <- function(id) {
      ns <- NS(id)
        fluentPage(
            Text("A randomly generated dataset of imaginary sales deals"),
            DetailsList(items = shiny.fluent::fluentSalesDeals, columns = columns)
        )
    }
    ```

    Remember to include `tibble` inside `box::use()`, else the code will not be able to use the package.

-   Upon running the app with all these changes, you should see the improved table -

```{r, echo=FALSE}
knitr::include_graphics("images/rhino_fluent_3.png")
```

## 3.

## Further Suggested Readings

-   [All about Rhino](https://appsilon.com/rhino-r-package-tutorial/)

-   [Reference for all Shiny.fluent functions](https://appsilon.github.io/shiny.fluent/reference/index.html)

-   [How to use shiny.fluent with Shiny modules](https://appsilon.github.io/shiny.fluent/articles/sz-how-to-shiny-modules.html)

-   [Tutorial: Create your first shiny.fluent dashboard](https://appsilon.github.io/shiny.fluent/articles/shiny-fluent.html)

-   [Tutorial: Full dashboard UI in Shiny and Fluent](https://appsilon.github.io/shiny.fluent/articles/st-sales-reps-dashboard.html)
